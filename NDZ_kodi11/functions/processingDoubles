# Funkcija processingDoubles(table, occurances) apstrādā tās dubultās rindas, 
# kur ir abi datumi gan sākuma kodam ailē [sak], gan ailē [beidz].
# Dubultās rindas vai vieninieki, kuriem ir datumi tikai vienā no šīm ailēm -
# vai nu ailē [sak], vai ailē [beidz], bet ne abās.
# apstrādāja attiecīgajās funkcijās processingTwoes(x,o) un processingOnes(x).

processingDoubles <- function(x, o) {
  #1 Pārbauda, vai tabula ir atbilstošā formātā:
  #  Tas ir, ka katrā pāra rindā ir viens NA ailē [sak] un
  #  viens NA ailē [beidz] ailē, bet ne vienā rindā abi, vai vienā ailē abi.
  #  Šajā kodā tos dēvē 'Īstie dubultnieki'.
  x <- x[order(x$ps_code, x$nm_code, x$NDZ_sanemsanas_datums), ]
  temp <- data.frame()

  for(k in seq(1, nrow(x), by = 2)) {
    if (is.na(x$sak)[k] && is.na(x$beidz[k + 1])
        || is.na(x$sak)[k + 1] && is.na(x$beidz[k])) {
      temp <- rbind(temp, x[c(k, k + 1),])
    }
  }
  rm(k)
  
  if(nrow(temp) == nrow(x)) {
    cat("PĀRBAUDE IZIETA: Visas rindas ir Īstie Divnieki.\n
    Īstie Divnieki nozīmē, ka ierakstu pārī, kur ps_code un nm_code sakrīt, viena rinda ir ar sak
    ierakstu otra ar beidz ierakstu, bet nevienā rindā nav abi: gan sak, gan beidz datumi.
    Īstie Divnieki ir rindas, kuras ir savienojamas uz vienu ierakstu, kurā būs gan sak datums,
    gan beidz datums.")
    rm(temp)
  } else {
    stop(cat("ERROR: Visas rindas NAV Īstie Divnieki. Pārskatīt tabulu.\n
       Īstie Divnieki nozīmē, ka ierakstu pārī, kur ps_code un nm_code sakrīt, viena rinda ir ar sak
       ierakstu otra ar beidz ierakstu, bet nevienā rindā nav abi: gan sak, gan beidz datumi.
       Īstie Divnieki ir rindas, kuras ir savienojamas uz vienu ierakstu, kurā būs gan sak datums,
       gan beidz datums."))
  }

#Atkarībā no occurances numura 'O', sadalām tā, lai ir tikai oriģināli divnieki.
# šis met kļūdas un es ne visai saprotu loģiku  šim.
  #Turi stingru secību un ievies pārbaudi, ka sākuma datums nav vēlāks par beigu datumu.
  # pagaidām šo izkomentēju ārā
#  t <- 0
#subtab_vec <- character()
#check_rows <- 0

#if (as.integer(o) <= nrow(x)) {
#  en <- floor(as.integer(o)/2)
#  floor(as.integer(10)/2)
#} else {
#  en <- nrow(x)/2
#}

#for (O in 1:en) {
#    subtab_name <- paste0("x", O)
#    temp_df <- data.frame()
#    for(b in seq(O+t, nrow(x), by = en-1)){
#      temp_df <- rbind(temp_df, x[c(b, b+1), ])
#    }
#    assign(subtab_name, temp_df)
#   check_rows <- check_rows + nrow(temp_df)
#    subtab_vec <- append(subtab_vec, subtab_name)
#   rm(subtab_name, temp_df, b)
#   if(check_rows == nrow(x)) {
#      break
#    }
#    t <- t + 1}

#rm(t, x, check_rows, en)
#####################

#2 Savienojam duplikātu rindas tā, lai sākuma un beigu datumi ir vienā ailē
  # !! Ok, šis dod ziņojumu, ka kaut kas nav līdz galam tā, kā vajag, bet rēķina pareizi.
x_savienotieDivnieki <- data.frame()
x <- x[order(x$period, x$ps_code, x$dnperk, x$nm_code, x$NDZ_sanemsanas_datums), ]

for (O in seq(1, nrow(x), by = 2)) {
 y <- x[c(O, O+1), ]
  
 if (y$NDZ_sanemsanas_datums[1] <= y$NDZ_sanemsanas_datums[2]) {
   result <- y %>%
     group_by(period, ps_code, dnperk, nm_code) %>%
     summarise(
       start = max(as.character(start), na.rm = TRUE),
       sak = max(sak, na.rm = TRUE),
       end = max(as.character(end), na.rm = TRUE),
       beidz = max(beidz, na.rm = TRUE),
       prof = max(as.character(prof), na.rm = TRUE),
       last_date = max(last_date, na.rm = TRUE)
     ) %>%
     arrange(ps_code) 
     x_savienotieDivnieki <- rbind(x_savienotieDivnieki, result)
 } else {
   stop(cat("Apstrādājot dubultniekus caur processingDouble(), kas nāk no", 
            o, "-nieku apstrādes, dubultnieku sākuma datums NAV agrāks vai 
            vienāds ar beigu datumu. TrueDoubles rindas: ", O, "un", O+1.))
 }
}
  
rm(y, result) 
  
#3 Pārbaudām vai izdalītās rindas sakrīt, vai ailēs [sak] un [beidz] nav NAs.
#Pārbaude uz dubultniekiem.
  
  if (nrow(x_savienotieDivnieki) * 2 == nrow(x)) {
    if (sum(is.na(x_savienotieDivnieki$sak)) == 0) {
      if (sum(is.na(x_savienotieDivnieki$beidz)) == 0) {
          cat("Funkcijā processingDoubles(), jaunizveidotā tabula x_savienotieDivnieki ir izgājusi pārbaudes un tālāk var sarēķināt dienas")
          rm(x)
      } else {
        stop(cat("Datumu ailē [beidz] ir NA vienības."))
      }
    } else {
      stop(cat("Datumu ailē [sak] ir NA vienības."))
    }
  } else {
    stop(cat("No Īsto Divnieku tabulas izvilktāts rindas nesakrīt."))
  }


rm(O)

#4 Tabulu x_savienotieDivnieki apstrādā sekojošos punktos.
# Piezīme, lai nesajauktu: 
# Lai arī tabulā x_savienotieDivnieki rindas ir pa vienai, datumi ir dubulti.
# Ar funkciju processingOnes() apstrādā tikai tos vieniniekus, 
# kuriem ir vai nu datums ailē [sak] vai ailē [beidz], 
# bet ne abās.

# Ja datumi ir abās ailēs, kā tās ir tabulās, ko apstrādā šī funkcija
# processingDoubles(), kas pārbauda un savieno vērtības, 
# tad dienu aprēķins tiek arī veikts tepat. 
# Un tad pārsūtīts uz temp_NDZ.
  
#5 Sakārto tabulu
  x <- x_savienotieDivnieki
  x <- x[order(x$ps_code, x$nm_code), ]
  rownames(x) <- NULL

#6 Aprēķini dienas no sak līdz beidz un ievieto tās ailē [dienas].

#LĒMUMS: 2
x$dienas1 <- as.numeric(difftime(as.Date(x$beidz), as.Date(x$sak), units = "days")) + 1  
  x$dienas <- x$dienas1[(!is.na(x$sak))]
  x$dienas1 <- NULL
  rm(x_savienotieDivnieki)
  
  x <- x[order(x$ps_code, x$nm_code), ]
 return(x)
  }
